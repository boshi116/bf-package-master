From 01f03e9e31de4c66b7abc1d139fd1451c2f5e361 Mon Sep 17 00:00:00 2001
From: monsoon <yjh1021317464@gmail.com>
Date: Sun, 28 Feb 2021 00:10:26 +0800
Subject: [PATCH] Add http+socks mixed inbound protocol

---
 infra/conf/mixed.go             |  45 +++++
 infra/conf/mixed_test.go        | 116 ++++++++++++
 infra/conf/xray.go              |   1 +
 proxy/mixed/bufconn.go          |  56 ++++++
 proxy/mixed/config.pb.go        | 302 ++++++++++++++++++++++++++++++++
 proxy/mixed/config.proto        |  28 +++
 proxy/mixed/errors.generated.go |   9 +
 proxy/mixed/mixed.go            |   3 +
 proxy/mixed/server.go           | 146 +++++++++++++++
 proxy/socks/protocol.go         |   5 +
 10 files changed, 711 insertions(+)
 create mode 100644 infra/conf/mixed.go
 create mode 100644 infra/conf/mixed_test.go
 create mode 100644 proxy/mixed/bufconn.go
 create mode 100644 proxy/mixed/config.pb.go
 create mode 100644 proxy/mixed/config.proto
 create mode 100644 proxy/mixed/errors.generated.go
 create mode 100644 proxy/mixed/mixed.go
 create mode 100644 proxy/mixed/server.go

diff --git a/infra/conf/mixed.go b/infra/conf/mixed.go
new file mode 100644
index 000000000..76d6b9f62
--- /dev/null
+++ b/infra/conf/mixed.go
@@ -0,0 +1,45 @@
+package conf
+
+import (
+	"github.com/golang/protobuf/proto"
+	"github.com/xtls/xray-core/proxy/mixed"
+)
+
+type MixedAccount struct {
+	Username string `json:"user"`
+	Password string `json:"pass"`
+}
+
+func (v *MixedAccount) Build() *mixed.Account {
+	return &mixed.Account{
+		Username: v.Password,
+		Password: v.Password,
+	}
+}
+
+type MixedServerConfig struct {
+	Accounts        []*MixedAccount `json:"accounts"`
+	Timeout         uint32          `json:"timeout"`
+	UserLevel       uint32          `json:"userLevel"`
+	SocksUDP        bool            `json:"socksUdp"`
+	SocksHost       *Address        `json:"socksIp"`
+	HttpTransparent bool            `json:"httpAllowTransparent"`
+}
+
+func (v *MixedServerConfig) Build() (proto.Message, error) {
+	config := new(mixed.ServerConfig)
+	if len(v.Accounts) > 0 {
+		config.Accounts = make(map[string]string, len(v.Accounts))
+		for _, account := range v.Accounts {
+			config.Accounts[account.Username] = account.Password
+		}
+	}
+	config.Timeout = v.Timeout
+	config.UserLevel = v.UserLevel
+	config.SocksUdpEnabled = v.SocksUDP
+	if v.SocksHost != nil {
+		config.SocksAddress = v.SocksHost.Build()
+	}
+	config.HttpAllowTransparent = v.HttpTransparent
+	return config, nil
+}
diff --git a/infra/conf/mixed_test.go b/infra/conf/mixed_test.go
new file mode 100644
index 000000000..e81d0ad50
--- /dev/null
+++ b/infra/conf/mixed_test.go
@@ -0,0 +1,116 @@
+package conf_test
+
+import (
+	"testing"
+
+	"github.com/xtls/xray-core/common/net"
+	. "github.com/xtls/xray-core/infra/conf"
+	"github.com/xtls/xray-core/proxy/mixed"
+)
+
+func TestMixedServerConfig(t *testing.T) {
+	creator := func() Buildable {
+		return new(MixedServerConfig)
+	}
+	runMultiTestCase(t, []TestCase{
+		{
+			Input:  `{}`,
+			Parser: loadJSON(creator),
+			Output: &mixed.ServerConfig{
+				Accounts:             nil,
+				Timeout:              0,
+				UserLevel:            0,
+				SocksUdpEnabled:      false,
+				SocksAddress:         nil,
+				HttpAllowTransparent: false,
+			},
+		},
+		{
+			Input: `{
+				"socksUdp": true
+			}`,
+			Parser: loadJSON(creator),
+			Output: &mixed.ServerConfig{
+				Accounts:             nil,
+				Timeout:              0,
+				UserLevel:            0,
+				SocksUdpEnabled:      true,
+				SocksAddress:         nil,
+				HttpAllowTransparent: false,
+			},
+		},
+		{
+			Input: `{
+				"accounts": [
+					{
+						"user": "user",
+						"pass": "pass"
+					}
+				]
+			}`,
+			Parser: loadJSON(creator),
+			Output: &mixed.ServerConfig{
+				Accounts: map[string]string{
+					"user": "pass",
+				},
+				Timeout:              0,
+				UserLevel:            0,
+				SocksUdpEnabled:      false,
+				SocksAddress:         nil,
+				HttpAllowTransparent: false,
+			},
+		},
+		{
+			Input: `{
+				"accounts": [
+					{
+						"user": "user",
+						"pass": "pass"
+					}
+				],
+				"socksUdp": true
+			}`,
+			Parser: loadJSON(creator),
+			Output: &mixed.ServerConfig{
+				Accounts: map[string]string{
+					"user": "pass",
+				},
+				Timeout:              0,
+				UserLevel:            0,
+				SocksUdpEnabled:      true,
+				SocksAddress:         nil,
+				HttpAllowTransparent: false,
+			},
+		},
+		{
+			Input: `{
+				"accounts": [
+					{
+						"user": "user",
+						"pass": "pass"
+					}
+				],
+				"timeout": 5,
+				"userLevel": 10,
+				"socksUdp": true,
+				"socksIp": "1.2.3.4",
+				"httpAllowTransparent": true
+			}`,
+			Parser: loadJSON(creator),
+			Output: &mixed.ServerConfig{
+				Accounts: map[string]string{
+					"user": "pass",
+				},
+				Timeout:         5,
+				UserLevel:       10,
+				SocksUdpEnabled: true,
+				SocksAddress: &net.IPOrDomain{
+					Address: &net.IPOrDomain_Ip{
+						Ip: []byte{1, 2, 3, 4},
+					},
+				},
+				HttpAllowTransparent: true,
+			},
+		},
+	})
+}
diff --git a/infra/conf/xray.go b/infra/conf/xray.go
index e21018a56..5153b3cde 100644
--- a/infra/conf/xray.go
+++ b/infra/conf/xray.go
@@ -25,6 +25,7 @@ var (
 		"vmess":         func() interface{} { return new(VMessInboundConfig) },
 		"trojan":        func() interface{} { return new(TrojanServerConfig) },
 		"mtproto":       func() interface{} { return new(MTProtoServerConfig) },
+		"mixed":         func() interface{} { return new(MixedServerConfig) },
 	}, "protocol", "settings")
 
 	outboundConfigLoader = NewJSONConfigLoader(ConfigCreatorCache{
diff --git a/proxy/mixed/bufconn.go b/proxy/mixed/bufconn.go
new file mode 100644
index 000000000..9f56fd5a9
--- /dev/null
+++ b/proxy/mixed/bufconn.go
@@ -0,0 +1,56 @@
+package mixed
+
+import (
+	"bufio"
+	"github.com/xtls/xray-core/common/net"
+	"github.com/xtls/xray-core/transport/internet"
+	"time"
+)
+
+type BufferedConnection struct {
+	reader *bufio.Reader
+	conn   internet.Connection
+}
+
+func NewBufferedConnection(conn internet.Connection) BufferedConnection {
+	return BufferedConnection{
+		reader: bufio.NewReader(conn),
+		conn:   conn,
+	}
+}
+
+func (c BufferedConnection) Peek(n int) ([]byte, error) {
+	return c.reader.Peek(n)
+}
+
+func (c BufferedConnection) Read(p []byte) (int, error) {
+	return c.reader.Read(p)
+}
+
+func (c BufferedConnection) Write(b []byte) (n int, err error) {
+	return c.conn.Write(b)
+}
+
+func (c BufferedConnection) Close() error {
+	return c.conn.Close()
+}
+
+func (c BufferedConnection) LocalAddr() net.Addr {
+	return c.conn.LocalAddr()
+}
+
+func (c BufferedConnection) RemoteAddr() net.Addr {
+	return c.conn.RemoteAddr()
+}
+
+func (c BufferedConnection) SetDeadline(t time.Time) error {
+	return c.conn.SetDeadline(t)
+}
+
+func (c BufferedConnection) SetReadDeadline(t time.Time) error {
+	return c.conn.SetReadDeadline(t)
+}
+
+func (c BufferedConnection) SetWriteDeadline(t time.Time) error {
+	return c.conn.SetWriteDeadline(t)
+}
diff --git a/proxy/mixed/config.pb.go b/proxy/mixed/config.pb.go
new file mode 100644
index 000000000..d854aaac3
--- /dev/null
+++ b/proxy/mixed/config.pb.go
@@ -0,0 +1,302 @@
+// Code generated by protoc-gen-go. DO NOT EDIT.
+// versions:
+// 	protoc-gen-go v1.25.0
+// 	protoc        v3.12.4
+// source: proxy/mixed/config.proto
+
+package mixed
+
+import (
+	proto "github.com/golang/protobuf/proto"
+	net "github.com/xtls/xray-core/common/net"
+	_ "github.com/xtls/xray-core/common/protocol"
+	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
+	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
+	reflect "reflect"
+	sync "sync"
+)
+
+const (
+	// Verify that this generated code is sufficiently up-to-date.
+	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
+	// Verify that runtime/protoimpl is sufficiently up-to-date.
+	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
+)
+
+// This is a compile-time assertion that a sufficiently up-to-date version
+// of the legacy proto package is being used.
+const _ = proto.ProtoPackageIsVersion4
+
+// Account represents a Socks/HTTP account.
+type Account struct {
+	state         protoimpl.MessageState
+	sizeCache     protoimpl.SizeCache
+	unknownFields protoimpl.UnknownFields
+
+	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
+	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
+}
+
+func (x *Account) Reset() {
+	*x = Account{}
+	if protoimpl.UnsafeEnabled {
+		mi := &file_proxy_mixed_config_proto_msgTypes[0]
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		ms.StoreMessageInfo(mi)
+	}
+}
+
+func (x *Account) String() string {
+	return protoimpl.X.MessageStringOf(x)
+}
+
+func (*Account) ProtoMessage() {}
+
+func (x *Account) ProtoReflect() protoreflect.Message {
+	mi := &file_proxy_mixed_config_proto_msgTypes[0]
+	if protoimpl.UnsafeEnabled && x != nil {
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		if ms.LoadMessageInfo() == nil {
+			ms.StoreMessageInfo(mi)
+		}
+		return ms
+	}
+	return mi.MessageOf(x)
+}
+
+// Deprecated: Use Account.ProtoReflect.Descriptor instead.
+func (*Account) Descriptor() ([]byte, []int) {
+	return file_proxy_mixed_config_proto_rawDescGZIP(), []int{0}
+}
+
+func (x *Account) GetUsername() string {
+	if x != nil {
+		return x.Username
+	}
+	return ""
+}
+
+func (x *Account) GetPassword() string {
+	if x != nil {
+		return x.Password
+	}
+	return ""
+}
+
+// ServerConfig is the protobuf config for Mixed server.
+type ServerConfig struct {
+	state         protoimpl.MessageState
+	sizeCache     protoimpl.SizeCache
+	unknownFields protoimpl.UnknownFields
+
+	Accounts map[string]string `protobuf:"bytes,1,rep,name=accounts,proto3" json:"accounts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
+	// Deprecated: Do not use.
+	Timeout   uint32 `protobuf:"varint,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
+	UserLevel uint32 `protobuf:"varint,3,opt,name=user_level,json=userLevel,proto3" json:"user_level,omitempty"`
+	// socks
+	SocksUdpEnabled bool            `protobuf:"varint,4,opt,name=socks_udp_enabled,json=socksUdpEnabled,proto3" json:"socks_udp_enabled,omitempty"`
+	SocksAddress    *net.IPOrDomain `protobuf:"bytes,5,opt,name=socks_address,json=socksAddress,proto3" json:"socks_address,omitempty"`
+	// http
+	HttpAllowTransparent bool `protobuf:"varint,6,opt,name=http_allow_transparent,json=httpAllowTransparent,proto3" json:"http_allow_transparent,omitempty"`
+}
+
+func (x *ServerConfig) Reset() {
+	*x = ServerConfig{}
+	if protoimpl.UnsafeEnabled {
+		mi := &file_proxy_mixed_config_proto_msgTypes[1]
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		ms.StoreMessageInfo(mi)
+	}
+}
+
+func (x *ServerConfig) String() string {
+	return protoimpl.X.MessageStringOf(x)
+}
+
+func (*ServerConfig) ProtoMessage() {}
+
+func (x *ServerConfig) ProtoReflect() protoreflect.Message {
+	mi := &file_proxy_mixed_config_proto_msgTypes[1]
+	if protoimpl.UnsafeEnabled && x != nil {
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		if ms.LoadMessageInfo() == nil {
+			ms.StoreMessageInfo(mi)
+		}
+		return ms
+	}
+	return mi.MessageOf(x)
+}
+
+// Deprecated: Use ServerConfig.ProtoReflect.Descriptor instead.
+func (*ServerConfig) Descriptor() ([]byte, []int) {
+	return file_proxy_mixed_config_proto_rawDescGZIP(), []int{1}
+}
+
+func (x *ServerConfig) GetAccounts() map[string]string {
+	if x != nil {
+		return x.Accounts
+	}
+	return nil
+}
+
+// Deprecated: Do not use.
+func (x *ServerConfig) GetTimeout() uint32 {
+	if x != nil {
+		return x.Timeout
+	}
+	return 0
+}
+
+func (x *ServerConfig) GetUserLevel() uint32 {
+	if x != nil {
+		return x.UserLevel
+	}
+	return 0
+}
+
+func (x *ServerConfig) GetSocksUdpEnabled() bool {
+	if x != nil {
+		return x.SocksUdpEnabled
+	}
+	return false
+}
+
+func (x *ServerConfig) GetSocksAddress() *net.IPOrDomain {
+	if x != nil {
+		return x.SocksAddress
+	}
+	return nil
+}
+
+func (x *ServerConfig) GetHttpAllowTransparent() bool {
+	if x != nil {
+		return x.HttpAllowTransparent
+	}
+	return false
+}
+
+var File_proxy_mixed_config_proto protoreflect.FileDescriptor
+
+var file_proxy_mixed_config_proto_rawDesc = []byte{
+	0x0a, 0x18, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2f, 0x6d, 0x69, 0x78, 0x65, 0x64, 0x2f, 0x63, 0x6f,
+	0x6e, 0x66, 0x69, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x10, 0x78, 0x72, 0x61, 0x79,
+	0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x6d, 0x69, 0x78, 0x65, 0x64, 0x1a, 0x18, 0x63, 0x6f,
+	0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x6e, 0x65, 0x74, 0x2f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
+	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x21, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x70,
+	0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x73,
+	0x70, 0x65, 0x63, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x41, 0x0a, 0x07, 0x41, 0x63, 0x63,
+	0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65,
+	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65,
+	0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01,
+	0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0xf6, 0x02, 0x0a,
+	0x0c, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x48, 0x0a,
+	0x08, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
+	0x2c, 0x2e, 0x78, 0x72, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x6d, 0x69, 0x78,
+	0x65, 0x64, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e,
+	0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x08, 0x61,
+	0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x12, 0x1c, 0x0a, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f,
+	0x75, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x42, 0x02, 0x18, 0x01, 0x52, 0x07, 0x74, 0x69,
+	0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6c, 0x65,
+	0x76, 0x65, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x75, 0x73, 0x65, 0x72, 0x4c,
+	0x65, 0x76, 0x65, 0x6c, 0x12, 0x2a, 0x0a, 0x11, 0x73, 0x6f, 0x63, 0x6b, 0x73, 0x5f, 0x75, 0x64,
+	0x70, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52,
+	0x0f, 0x73, 0x6f, 0x63, 0x6b, 0x73, 0x55, 0x64, 0x70, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64,
+	0x12, 0x40, 0x0a, 0x0d, 0x73, 0x6f, 0x63, 0x6b, 0x73, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
+	0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x78, 0x72, 0x61, 0x79, 0x2e, 0x63,
+	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x6e, 0x65, 0x74, 0x2e, 0x49, 0x50, 0x4f, 0x72, 0x44, 0x6f,
+	0x6d, 0x61, 0x69, 0x6e, 0x52, 0x0c, 0x73, 0x6f, 0x63, 0x6b, 0x73, 0x41, 0x64, 0x64, 0x72, 0x65,
+	0x73, 0x73, 0x12, 0x34, 0x0a, 0x16, 0x68, 0x74, 0x74, 0x70, 0x5f, 0x61, 0x6c, 0x6c, 0x6f, 0x77,
+	0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01,
+	0x28, 0x08, 0x52, 0x14, 0x68, 0x74, 0x74, 0x70, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x54, 0x72, 0x61,
+	0x6e, 0x73, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x1a, 0x3b, 0x0a, 0x0d, 0x41, 0x63, 0x63, 0x6f,
+	0x75, 0x6e, 0x74, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
+	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76,
+	0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
+	0x65, 0x3a, 0x02, 0x38, 0x01, 0x42, 0x52, 0x0a, 0x14, 0x63, 0x6f, 0x6d, 0x2e, 0x78, 0x72, 0x61,
+	0x79, 0x2e, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2e, 0x6d, 0x69, 0x78, 0x65, 0x64, 0x50, 0x01, 0x5a,
+	0x25, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x78, 0x74, 0x6c, 0x73,
+	0x2f, 0x78, 0x72, 0x61, 0x79, 0x2d, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x78, 0x79,
+	0x2f, 0x6d, 0x69, 0x78, 0x65, 0x64, 0xaa, 0x02, 0x10, 0x58, 0x72, 0x61, 0x79, 0x2e, 0x50, 0x72,
+	0x6f, 0x78, 0x79, 0x2e, 0x4d, 0x69, 0x78, 0x65, 0x64, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
+	0x33,
+}
+
+var (
+	file_proxy_mixed_config_proto_rawDescOnce sync.Once
+	file_proxy_mixed_config_proto_rawDescData = file_proxy_mixed_config_proto_rawDesc
+)
+
+func file_proxy_mixed_config_proto_rawDescGZIP() []byte {
+	file_proxy_mixed_config_proto_rawDescOnce.Do(func() {
+		file_proxy_mixed_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_proxy_mixed_config_proto_rawDescData)
+	})
+	return file_proxy_mixed_config_proto_rawDescData
+}
+
+var file_proxy_mixed_config_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
+var file_proxy_mixed_config_proto_goTypes = []interface{}{
+	(*Account)(nil),        // 0: xray.proxy.mixed.Account
+	(*ServerConfig)(nil),   // 1: xray.proxy.mixed.ServerConfig
+	nil,                    // 2: xray.proxy.mixed.ServerConfig.AccountsEntry
+	(*net.IPOrDomain)(nil), // 3: xray.common.net.IPOrDomain
+}
+var file_proxy_mixed_config_proto_depIdxs = []int32{
+	2, // 0: xray.proxy.mixed.ServerConfig.accounts:type_name -> xray.proxy.mixed.ServerConfig.AccountsEntry
+	3, // 1: xray.proxy.mixed.ServerConfig.socks_address:type_name -> xray.common.net.IPOrDomain
+	2, // [2:2] is the sub-list for method output_type
+	2, // [2:2] is the sub-list for method input_type
+	2, // [2:2] is the sub-list for extension type_name
+	2, // [2:2] is the sub-list for extension extendee
+	0, // [0:2] is the sub-list for field type_name
+}
+
+func init() { file_proxy_mixed_config_proto_init() }
+func file_proxy_mixed_config_proto_init() {
+	if File_proxy_mixed_config_proto != nil {
+		return
+	}
+	if !protoimpl.UnsafeEnabled {
+		file_proxy_mixed_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
+			switch v := v.(*Account); i {
+			case 0:
+				return &v.state
+			case 1:
+				return &v.sizeCache
+			case 2:
+				return &v.unknownFields
+			default:
+				return nil
+			}
+		}
+		file_proxy_mixed_config_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
+			switch v := v.(*ServerConfig); i {
+			case 0:
+				return &v.state
+			case 1:
+				return &v.sizeCache
+			case 2:
+				return &v.unknownFields
+			default:
+				return nil
+			}
+		}
+	}
+	type x struct{}
+	out := protoimpl.TypeBuilder{
+		File: protoimpl.DescBuilder{
+			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
+			RawDescriptor: file_proxy_mixed_config_proto_rawDesc,
+			NumEnums:      0,
+			NumMessages:   3,
+			NumExtensions: 0,
+			NumServices:   0,
+		},
+		GoTypes:           file_proxy_mixed_config_proto_goTypes,
+		DependencyIndexes: file_proxy_mixed_config_proto_depIdxs,
+		MessageInfos:      file_proxy_mixed_config_proto_msgTypes,
+	}.Build()
+	File_proxy_mixed_config_proto = out.File
+	file_proxy_mixed_config_proto_rawDesc = nil
+	file_proxy_mixed_config_proto_goTypes = nil
+	file_proxy_mixed_config_proto_depIdxs = nil
+}
diff --git a/proxy/mixed/config.proto b/proxy/mixed/config.proto
new file mode 100644
index 000000000..2083052e1
--- /dev/null
+++ b/proxy/mixed/config.proto
@@ -0,0 +1,28 @@
+syntax = "proto3";
+
+package xray.proxy.mixed;
+option csharp_namespace = "Xray.Proxy.Mixed";
+option go_package = "github.com/xtls/xray-core/proxy/mixed";
+option java_package = "com.xray.proxy.mixed";
+option java_multiple_files = true;
+
+import "common/net/address.proto";
+import "common/protocol/server_spec.proto";
+
+// Account represents a Socks/HTTP account.
+message Account {
+  string username = 1;
+  string password = 2;
+}
+
+// ServerConfig is the protobuf config for Mixed server.
+message ServerConfig {
+  map<string, string> accounts = 1;
+  uint32 timeout = 2 [deprecated = true];
+  uint32 user_level = 3;
+  // socks
+  bool socks_udp_enabled = 4;
+  xray.common.net.IPOrDomain socks_address = 5;
+  // http
+  bool http_allow_transparent = 6;
+}
diff --git a/proxy/mixed/errors.generated.go b/proxy/mixed/errors.generated.go
new file mode 100644
index 000000000..9df22f884
--- /dev/null
+++ b/proxy/mixed/errors.generated.go
@@ -0,0 +1,9 @@
+package mixed
+
+import "github.com/xtls/xray-core/common/errors"
+
+type errPathObjHolder struct{}
+
+func newError(values ...interface{}) *errors.Error {
+	return errors.New(values...).WithPathObj(errPathObjHolder{})
+}
diff --git a/proxy/mixed/mixed.go b/proxy/mixed/mixed.go
new file mode 100644
index 000000000..5f2bc87e0
--- /dev/null
+++ b/proxy/mixed/mixed.go
@@ -0,0 +1,3 @@
+package mixed
+
+//go:generate go run github.com/xtls/xray-core/common/errors/errorgen
diff --git a/proxy/mixed/server.go b/proxy/mixed/server.go
new file mode 100644
index 000000000..404e46236
--- /dev/null
+++ b/proxy/mixed/server.go
@@ -0,0 +1,146 @@
+package mixed
+
+import (
+	"context"
+	"github.com/xtls/xray-core/common"
+	"github.com/xtls/xray-core/common/net"
+	"github.com/xtls/xray-core/common/session"
+	"github.com/xtls/xray-core/features/routing"
+	"github.com/xtls/xray-core/proxy/http"
+	"github.com/xtls/xray-core/proxy/socks"
+	"github.com/xtls/xray-core/transport/internet"
+)
+
+// Server is a Mixed proxy server
+type Server struct {
+	httpServer        http.Server
+	socksServer       socks.Server
+	socksOnlyNetworks []net.Network
+	httpOnlyNetworks  []net.Network
+	intersectNetworks []net.Network
+}
+
+// NewServer creates a new Server object.
+func NewServer(ctx context.Context, config *ServerConfig) (*Server, error) {
+	httpServer, err := http.NewServer(
+		ctx,
+		&http.ServerConfig{
+			Timeout:          config.Timeout,
+			Accounts:         config.Accounts,
+			AllowTransparent: config.HttpAllowTransparent,
+			UserLevel:        config.UserLevel,
+		},
+	)
+	if err != nil {
+		return nil, newError("Errors in http config").Base(err).AtError()
+	}
+	socksAuthType := socks.AuthType_NO_AUTH
+	if len(config.Accounts) > 0 {
+		socksAuthType = socks.AuthType_PASSWORD
+	}
+	socksServer, err := socks.NewServer(
+		ctx,
+		&socks.ServerConfig{
+			AuthType:   socksAuthType,
+			Accounts:   config.Accounts,
+			Address:    config.SocksAddress,
+			UdpEnabled: config.SocksUdpEnabled,
+			Timeout:    config.Timeout,
+			UserLevel:  config.UserLevel,
+		})
+	if err != nil {
+		return nil, newError("Errors in socks config").Base(err).AtError()
+	}
+
+	socksNetworks := socksServer.Network()
+	httpNetworks := httpServer.Network()
+
+	socksOnlyNetworks := make([]net.Network, 0)
+	httpOnlyNetworks := make([]net.Network, 0)
+	intersectNetworks := make([]net.Network, 0)
+
+	for _, n := range socksNetworks {
+		if !isInNetworkSlice(n, &httpNetworks) {
+			socksOnlyNetworks = append(socksOnlyNetworks, n)
+		} else {
+			intersectNetworks = append(intersectNetworks, n)
+		}
+	}
+
+	for _, n := range httpNetworks {
+		if !isInNetworkSlice(n, &socksNetworks) {
+			httpOnlyNetworks = append(httpOnlyNetworks, n)
+		}
+	}
+
+	s := &Server{
+		httpServer:        *httpServer,
+		socksServer:       *socksServer,
+		socksOnlyNetworks: socksOnlyNetworks,
+		httpOnlyNetworks:  httpOnlyNetworks,
+		intersectNetworks: intersectNetworks,
+	}
+	return s, nil
+}
+
+// Network implements proxy.Inbound.
+func (s *Server) Network() []net.Network {
+	returnNetwork := append(s.intersectNetworks, s.socksOnlyNetworks...)
+	returnNetwork = append(returnNetwork, s.httpOnlyNetworks...)
+	return returnNetwork
+}
+
+// Process implements proxy.Inbound.
+func (s *Server) Process(ctx context.Context, network net.Network, conn internet.Connection, dispatcher routing.Dispatcher) error {
+
+	// socks only
+	if isInNetworkSlice(network, &s.socksOnlyNetworks) {
+		newError("Connection is identified as a Socks connection").AtDebug().WriteToLog(session.ExportIDToError(ctx))
+		return s.socksServer.Process(ctx, network, conn, dispatcher)
+	}
+
+	// http only
+	if isInNetworkSlice(network, &s.httpOnlyNetworks) {
+		newError("Connection is identified as a HTTP connection").AtDebug().WriteToLog(session.ExportIDToError(ctx))
+		return s.httpServer.Process(ctx, network, conn, dispatcher)
+	}
+
+	// no UDP for BufferedConnection
+	if network == net.Network_UDP {
+		return newError("UDP is only available for Socks").AtError()
+	}
+
+	// read first byte to distinguish HTTP and Socks
+	bufferedConnection := NewBufferedConnection(conn)
+	firstByte, err := bufferedConnection.Peek(1)
+	if err != nil {
+		return newError("Read first byte failed").Base(err).AtError()
+	}
+	newError("First byte", firstByte).AtDebug().WriteToLog(session.ExportIDToError(ctx))
+
+	if firstByte[0] == socks.Socks4Version || firstByte[0] == socks.Socks5Version {
+		newError("Connection is identified as Socks connection").AtDebug().WriteToLog(session.ExportIDToError(ctx))
+		return s.socksServer.Process(ctx, network, bufferedConnection, dispatcher)
+	} else {
+		newError("Connection is identified as a HTTP connection").AtDebug().WriteToLog(session.ExportIDToError(ctx))
+		return s.httpServer.Process(ctx, network, bufferedConnection, dispatcher)
+	}
+}
+
+func init() {
+	common.Must(common.RegisterConfig((*ServerConfig)(nil), func(ctx context.Context, config interface{}) (interface{}, error) {
+		return NewServer(ctx, config.(*ServerConfig))
+	}))
+}
+
+// isInNetworkSlice gets whether the network is in slice
+func isInNetworkSlice(network net.Network, networks *[]net.Network) bool {
+	found := false
+	for _, n := range *networks {
+		if network == n {
+			found = true
+			break
+		}
+	}
+	return found
+}
diff --git a/proxy/socks/protocol.go b/proxy/socks/protocol.go
index 29b9c9139..caa0805e5 100644
--- a/proxy/socks/protocol.go
+++ b/proxy/socks/protocol.go
@@ -32,6 +32,11 @@ const (
 	statusCmdNotSupport = 0x07
 )
 
+const (
+	Socks5Version = socks5Version
+	Socks4Version = socks4Version
+)
+
 var addrParser = protocol.NewAddressParser(
 	protocol.AddressFamilyByte(0x01, net.AddressFamilyIPv4),
 	protocol.AddressFamilyByte(0x04, net.AddressFamilyIPv6),
